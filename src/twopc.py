import socket
import select

# Two Phase commit

# This function shows the two-phase commit protocol
# used by the transaction coordinator and the shards

# Problem: This function tries to do a two phase commit
# to commit transactions
# If this function function is called it means that
# A client has issued a commit request and it must be
# committed
# Here we do not take into account the case were the
# the client disconnects before committing
# So if initCommit is called we resend messages until it
# is done
#
# We assume in this code that the communication channels
# are Fifo and the implementation will ensure the messages
# are delivered at most once
#
# Arguments:
# - The Id of the transaction that need to be committed.
# - The list of participants, this list is generated by
# the Transaction manager
# - Dependency of the transaction

# All message are sent in the following format
#

TIMEOUT = None


def initCommit(transactionID, listOfParticipants, dependency):
    voteCounter = 0
    prepareMsg = (transactionID, "prepare", listOfParticipants, dependency)
    nbParticpants = listOfParticipants.size()
    proposedClocks = dict()
    msgRecv = None

    # Sending a prepare message to all participants
    for participant in listOfParticipants:
        participant.send(prepareMsg)

    # Loop till all the message are received
    # Answers are expected in the following format
    # { Participant ID, Transaction ID, Message, Value }
    while len(proposedClocks) != nbParticpants:
        # assert (voteCounter < listOfParticipants.size())
        ready = select.select([mysocket], [], [], TIMEOUT)
        if ready[0]:
            msgRecv = socket.recv()
        else:
            for participant in listOfParticipants:
                if participant not in proposedClocks:
                    participant.send(prepareMsg)
        assert msgRecv != None

        # Parsing received message
        participantID = msgRecv[0]
        receivedTID = msgRecv[1]
        messageType = msgRecv[2]
        proposedClock = msgRecv[3]

        assert receivedTID == transactionID
        if messageType == "accept":
            proposedClocks[participantID] = proposedClock
        elif messageType == "abort":
            break
        else:
            assert False

    # Check if the list of keys matches the participants
    # In the dict
    assert not (len(proposedClocks) > nbParticpants)

    if len(proposedClocks) < nbParticpants:
        abortMsg = (transactionID, "abort", None, dependency)
        for participant in listOfParticipants:
            participant.send(abortMsg)

    elif len(proposedClocks) == nbParticpants:
        assert len(proposedClocks) == nbParticpants
        commitMsg = (transactionID, "commit", max(proposedClocks), dependency)

        for participant in listOfParticipants:
            participant.send(commitMsg)
    else:
        assert False

    return True


def initAbort(transactionID, listOfParticipants):
    nbParticpants = listOfParticipants.size()

    for participant in listOfParticipants:
        abortMsg = (transactionID, "abort", None, None)
        for participant in listOfParticipants:
            participant.send(abortMsg)

    return True
